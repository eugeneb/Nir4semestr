clear;
T = 1e-3;                 % Длительность анализируемой выборки сигнала
fd = 10e6;                % Частота дискретизации
Td = 1/fd;                % Интервал дискретизации
Nd = fix(T/Td);           % Количество отсчётов
phi = 2*pi*rand(1, 1);    % Случайная начальная фаза сигнала
fi = 1e6;                 % Частота сигнала

% Здесь ошибка, приводящая к неправильному спектру
%   TPSP=10e-3;            %период дальномерного кода
%   10e-3 = 0.010 c = 10 мс, а длительность ПСП ГЛОНАСС 1 мс
% Должно быть так:
    TPSP = 1e-3;
    
    
PNSize=511;            %количество символов дальномерного кода на 1 период

% Тут проблема, которая проявится далее - размер массива PN должен быть 1*511, а не 511*1
%   PN=sign(randn(511,1)); %дальномерный код
% Поэтому должно быть так
PN = sign(randn(1, 511));

% Код правильный, неправильный комментарий, время не случайно. Это просто массив отсчётов времени от 0 до Td*Nd=1 мс
t = Td*(0:Nd-1);       %массив случайного времени

Tpn=TPSP/PNSize;       % длительность одного симпвола ПСП

ind=mod(fix(t/Tpn),PNSize)+1;% массив индексов
PSP=PN(ind);       %растянутая последовательность 

% Зачем сформировано "несущее колебание"?
%    s =cos(2*pi* t);   %несущее колебание
% Здесь ошибка, нет умножения на несущую частоту
% Но далее массив s вообще не используется
% Вместо этого формируется массив K путём вычисления синуса заново
%    K=PSP*(sin(2*pi*fi * t)); %модулированный сигнал
% Кроме того, здесь существенная проблема
% Matlab рассматривает всё, как матрицы. Массив PSP и массив sin(...) в том числе. И перемножает их, как матрицы
% В результате объём массива K получается 1000*1000, что совсем неправильно.
% Действительно, если посмотреть в исходной программе:
%  size(PSP) = 1000*1
%  size(sin(2*pi*fi * t) = 1*1000
% При перемножении таких матриц получится матрица 1000*1000
% Но ведь предполагалось, что это будет одномерный массив с выборкой сигнала!
% Для решения проблемы надо, чтобы размеры массивов совпадали и были равны 1*1000
% А перемножение использовать поэлементное, т.е. "PSP .* cos(...)", а не "PSP * cos(...)"

% Следовало бы сделать так:
ref = cos(2*pi * fi * t + phi);  % Сюда добавлена случайная начальная фаза phi из начала программы
                                % Она пока неважна, но в будущем при дальнейшей разработке пригодится
                                % В конечном счёте, так более правильно
s = PSP .* ref;                 % Не формируем несущую заново, а используем массив ref. И поэлементное умножение ".*"!
% Теперь размер массива равен 1*1000

% Лучше сразу использовать другие обозначения, чтобы потом не путаться
%   Y=abs(fft(K));  %расчет спектра     
%   Y = fftshift(Y); 
% Обычно s - сигнал, S - спектр, K - коэффициенты фильтра
S = fftshift(fft(s));


f = fd/2 * ((0:Nd-1)-Nd/2)/(Nd/2);
plot(f/1e6, 20*log10(S/max(S)));

grid on
xlim([-4,+4]);
ylabel('S, dB');
xlabel('Frequency, MHz')
